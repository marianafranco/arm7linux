%
%~~
%~~  O Sistema Operacional KinOS
%~~
%

\chapter{O Sistema Operacional KinOS} \label{chap:sistema}
\index{sistema}




%Lembretes:
%\begin{itemize}
%\item{Escrever algo aqui}
%\item{Explicar em algum lugar as divisões que existem no assembly.}
%\item{Ver como colocar referencias e colocar a referencia das figuras}
%\item{Colocar a referencia das seções}
%\item{Variáveis em assembly}
%\item{Explicar que o código foi baseado na experiencia do mutex}
%\item{Na descricao do fork poderia dizer que ao duplicar a pilha estah copiando as variaveis locais; isto eh, embora as variaveis globais sejam comuns a todos os processos (e por isso eles talvez devessem ser chamados de threads), as variaveis locais sao copiadas.}
%\item{Daria para fazer uns testes com variaveis locais, mostrando que depois de se criar dois processos; os dois estao com variaveis locais diferentes?}
%\end{itemize}

\section{Organização}

Nesta etapa descreveremos algumas das estruturas de dados em assembly que utilizamos em nosso projeto, assim como organizamos a memória na placa e utilizamos os modos. O código está estruturado da maneira indicada na tabela \ref{codigo}.

\begin{center}
\begin{table}[ht!]
\begin{tabular}{|c|c|}
\hline
\textbf{Arquivo}	&	\textbf{Função}\\
\hline
startup.s & Inicialização em assembly ARM\\
cinit.c & Inicialização em C\\
button, dips, segment e timer & Rotinas de inicialização e uso dos periféricos\\
fork.s & Rotina de duplicação de processo em assembly\\
handler.s & Rotina de tratamento de interrupcões em assembly\\
mutex.mcp & Arquivo de projeto do CodeWarrior\\
rpsarmul.h & Arquivo com as constantes da placa e do emulador\\
tasks & Processos a serem executados\\
irq e swi & Inicialização e controle das interrupções de HW e SW\\
\hline
\end{tabular}
\caption{Relação de arquivos com suas funções\label{codigo}}
\end{table}
\end{center}

\subsection{Process Control Block}

O Process Control Block (ou simplesmente PCB), é um estrutura de dados que guarda todas as informações de uma thread que aguarda para ser executada enquanto outras estão usando o processador. Temos um PCB para cada uma das nove threads, onde cada uma ocupa 68 bytes. Estes 68 bytes estão estruturados como explicitado na figura \ref{pcb}. Cada posição da tabela ocupa uma palavra (4 bytes). A primeira posição é a base do PCB menos quatro bytes, a segunda a base menos oito bytes e assim por diante. Como podemos observar pela figura, as posições um a quinze (base - 4 a base - 60) armazenam o conteúdo dos registradores r0 a r14 do modo user em ordem inversa. A posição dezesseis (base - 64) armazena o registrador quatorze do modo IRQ, que nada mais é o endereço de retorno (link register) da interrupção que realizou a troca de processos. Finalmente, a posição dezessete armazena o registrador de estado do modo user. Estes registradores armazenados permitem estabelecer um ``snapshot'' preciso do estado do processo quando houve o chaveamento, e permite que este estado seja restabelecido quando for o turno deste processo voltar a ser executado. Esta estrutura tem seu espaço reservado no arquivo handler.s, e é nomeado com a variável handler\_task\_bottom, que indica a base da estrutura. Cada um dos PCBs está logo a seguir do anterior. Por exemplo, para acessarmos o segundo PCB, devemos subtrair 68 do endereço de base, 136 bytes para o terceiro PCB e assim por diante.

\begin{figure}[!ht]
\centering 
\includegraphics[height=10cm]{figuras/pcb.pdf}
\caption{Estrutura de dados do PCB. Fonte: \cite{aaa} \label{pcb}}
\end{figure}

\subsection{Lista de processos}

A lista de processos é um vetor que armazena quais dos processos estão ativos e quais não estão. Este vetor tem 40 bytes, onde 4 são para cada processo. Ele é declarado no arquivo handler.s com o nome de Process\_Table, que indica sua base. Cada endereço reservado deve ter o valor 0, caso o processo esteja inativo ou 1, caso esteja ativo.

\subsection{Memória}

Estruturamos a memória utilizada como indicado na figura \ref{memoria}. Para todo espaço das pilhas, programas, kernel, vetor de interrupções e área de dados, vamos limitar o espaço disponível para 128KB (de 0x0 a 0x20000).Como pode ser visto na seção \ref{bbb}, a memória entre 0x0 e 0x20 contém o vetor de interrupções e deve ser reservado. A pilha do modo SVC começa no endereço 0x7F80, cresce para baixo e não deve invadir a área reservada para o vetor de interrupção. Já a pilha do modo IRQ, começa no endereço 0x8000, também cresce para baixo e não deve invadir o espaço reservado para a pilha do modo SVC. O código do kernel e dos programas começa no endereço 0x8000, mas ao contrário da pilha do modo SVC, cresce para cima. Logo após o código, temos uma área reservada para os dados globais. Finalmente, as pilhas de usuário começam no endereço 0x20000 e crescem para baixo. Cada uma tem um offset relativo à anterior de 4048 bytes.

\begin{figure}[!ht]
\centering 
\includegraphics[height=13cm]{figuras/memoria.pdf}
\caption{Estrutura da memória. Fonte: \cite{aaa} \label{memoria}}
\end{figure}

\subsection{Modos}

Dentre os sete modos dsiponíveis na placa, utilizamos apenas três deles: o modo user, o modo SVC e o modo IRQ. O primeiro é o modo não privilegiado no qual rodamos os processos. O segundo, é o modo de inicialização do kernel e de execução das system calls, que é privilegiado. Já o terceiro, é um modo que também é privilegiado, mas que é usado quando há interrupções de hardware e portanto, é usado quando há o chaveamento de processos (interrupção de timer) ou qualquer outra interrupção que não a de software.

\subsection{Modos de operação}

Debugar o código com a placa não é possível em todas as situações. Quando o código que está sendo executado está dentro de uma região onde as interrupções estão desabilitadas, como no código de tratamento de interrupção, não podemos debugar o programa na placa. Para contornar tal problema, utilizamos o emulador disponível na IDE CodeWarrior, o ARMulator. Como ele foi desenvolvido para vários modelos de placa, utiliza endereços de periféricos diferentes da placa Evaluator 7-T, e além disso, não têm o módulo Angel de debug. Para manter a compatibilidade entre o emulador e a placa, nas partes onde o código se diferencia, como na inicialização do timer, colocamos ambos códigos. A seleção de qual dos dois será executado depende de uma variável global emulator, que é declarada no arquivo rpsarmul.h. Caso seja 1, o código executado é o do emulador, caso seja 0, é o código da placa.

\section{Angel}

O Angel é um programa contido na ROM da placa que realiza a comunicação entre a mesma e o computador que efetuou o upload do código. Além de permitir com que o código seja carregado na placa, o Angel realiza o processo de debug do código durante a execução. Para isso, deve haver uma comunicação constante entre a placa e o computador, que é feita através de interrupções constantes. Uma vez que a placa é iniciada, o endereço do vetor de interrupções responsável pelas interrupções de hardware e se software apontam para um endereço pré-estabelecido do Angel. Caso queiramos adicionar alguma rotina de tratamento de interrupções, não podemos de nos esquecer de encadear a rotina do Angel caso identifiquemos que a fonte de interrupção não foi de algo causado por um código do usuário. Descreveremos mais à frente como isso é feito durante a instalação da rotina de tratamento de interrupções.

\section{Inicialização}

O início do programa se dá no arquivo assembly statup.s. Nele, são feitas todas as operações que não podem ser feitas no código em C, como a inicialização das pilhas ou a criação da tabela de processos. Após esta etapa, a uma inicialização em C, feita no arquivo cinit.c, que ao fim de sua execução, roda o primeiro processo.

\subsection{Modo}

O primeiro passo do programa é informar qual o tipo de código que será executado no programa. Como descrito anteriormente, podemos ter o assembly ARM ou o assembly thumb. Em nosso programa, utlizaremos apenas código ARM, já que ele fornece mais instruções (favorece a legibilidade) e porque o tamanho do código não é um grande problema.

\subsection{Pilhas}

A fim de podemos utilizar as pilhas, precisamos inicializá-las em cada um dos modos que virão a ser utilizados. Em nosso programa, utilizamos os modos SVC, user e IRQ. Para inicializar as pilhas, devemos primeiro mudar o modo, desabilitar as interrupções temporariamente e só depois mudar o ponteiro de pilha. Podemos fazer os dois primeiros passos de uma vez só, já que estas operações são feitas através do registrador de estado, como descrito anteriormente. Porém, um problema nos surge ao tentarmos inicializar o ponteiro de pilha do modo user: uma vez que entremos neste modo, não podemos ir para nenhum outro estado privilegiado. A solução para este problema é que ao invés de mudarmos para o modo de usuário, vamos ao modo system, que nada mais é do que o modo usuário privilegiado. 

Como podemos ver na figura \ref{organmem}, a pilha do modo user começa no endereço 0x20000, a do modo IRQ em 0x8000 e a do modo SVC em 0x7F80. Como convenção para todas as pilhas que utilizaremos, não podemos nos esquecer que elas crescem sempre para baixo.

\subsection{Tabela de processos}

Uma vez inicializadas as pilhas, podemos inicializar também a tabela de processos. Quando estamos inicializando o kernel, apenas um programa está a funcionar. Portanto, colocamos 0 em todas as entradas da tabela de processos, indidicando que os processos estão inativos, menos para o processo 1, que nada mais é que o primeiro programa a ser rodado após a inicialização. Além disso, devemos setar como o processo atual (variável handler\_currenttaskid\_str, declarada em handler.s), o processo 1.

Após este ponto, o código pode ser escrito em C, já que inicializamos todas as estruturas de baixo nível. Portando, passamos o controle para o arquivo C\_Entry, que vai continuar com o processo de inicialização descrito a partir do item abaixo.

\subsection{Periféricos}

Para cada periférico da placa, como o display de sete segmentos, o DIP switch, os botões, o timer e os LEDs, há uma rotina de inicialização. Elas consitem apenas em habilitar flags e são executadas logo no início da etapa C do processo de inicialização da placa.

\subsection{Instalação do tratamento de interrupção}

Como á foi descrito anteriormente na seção \ref{ccc}, quando uma interrupção ocorre, a instrução no endereço 0x18 é executada caso ela seja uma interrupção de hardware ou no endereço 0x08 caso seja uma interrupção de software. Portanto, devemos colocar instruções adequadas nestas posições, o que é feito pela rotina de instalação do tratamento de interrupção.

A rotina de tratamento de interrupção funciona de modo similar para interrupções de hardware e se software. Em ambos os casos, recebemos o endereço da posição do vetor de interrupções onde ela deve ser instalada e o endereço da rotina que será executada quando uma interrupção ocorre. Com isso, adicionamos através de uma máscara a instrução branch.

Porém, há um caso especial quando executamos o código com a placa. Como já descrito anteriormente na seção \ref{ddd}, o Angel se utiliza das interrupções de hardware e software para se comunicar com a placa. Portanto, se apenas modificarmos o código e substituirmos a instrução que está contida no vetor de interrupção, essa comunicação não se realiza e tanto a placa quanto o programa de debugger travam. Para solucionarmos este problema, devemos passar para a rotina de tratamento de interrupção os endereços que estavam anteriormente no vetor de interrupção, para o caso da interrupção ser do Angel, a rotina correta ser executada (vide figura \ref{chain}).

\begin{figure}[!ht]
\centering 
\includegraphics[width=13cm]{figuras/chain.pdf}
\caption{Encadeamento de interrupções. Fonte: \cite{aaa} \label{chain}}
\end{figure}

\subsection{Interrupção de timer}

A fim de se utilizar as interrupções de timer para o chaveamento de processos, devemos além de inicializá-lo, definir algumas configurações como o tempo para a interrupção.

\subsection{Habilitando interrupções}

O último passo antes de se começar a executar o código do primeiro programa é habilitar simultaneamente o modo user e as interrupções de hardware. Como isso só pode ser feito por código assembly, temos de usar a instrução especial de C \_\_asm. Finalmente, após este passo passamos o controle para o primeiro processo.

\section{Processos}

O kernel pode lidar com no máximo nove processos, nomeados de task1 a task9 no arquivo tasks.c. Como eles não têm área de dados própria, não poderíamos chamá-los de processos. A implicação de se ter uma área de dados em comum é que todos os processos que rodam um mesmo programa compartilham os valores das variáveis. O mais correto, porntanto, seria o chamá-os de threads.

Criamos algums programas exemplo que se utilizam dos periféricos da placa. \ldots

\section{Chaveamento de processos}

O chaveamento de processos é realizado inteiramente com o assembly escrito no arquivo handler.s. Nele, o estado do processo que está sendo executado é armazenado e o próximo processo, obtido através de round-robin, é colocado para execução.

\subsection{Identificação da interrupção}

Uma vez que há a interrupção de timer, a chamada de interrupção de hardware é realizada. Durante a instalação da rotina de tratamento de interrupção de hardware, apontamos para a rotina handler caso estejamos usando a placa ou a rotina handler\_emulator caso estajamos usando o emulador. A direrença básica é que enquanto a primeira tenta identificar qual a fonte de interrupção que pode ser tanto o timer quando o Angel, a segunda já assume que a fonte é o timer, já que não há o Angel no emulador. Devemos salientar que deve-se armazenar toda informação contida nos registradores que é alterada durante o processo de tratamento de interrupção. Para tal, empilhamos os valores dos registradores usados a fim de se poder recuperar estes valores durante a etapa de salvamento do estado atual.

No caso do uso da placa, a fonte da interrupção se encontra no endereço 0x03ff4004, identificado como INTPND. Se o valor contido neste endereço é 0x0400, a fonte foi uma interrupção de timer, caso seja 0x0001, a fonte foi o botão da placa e caso contrário, a fonte foi o Angel.

\subsection{Recomeçar o timer}

Quando é identificada a iterrupção de timer, devemos reinicializar o contador do timer a fim de que possa interromper novamente no futuro. Para tal, executamos a rotina timer\_irq, encontrada no arquivo irq.c.

\subsection{Identificação do PCBs da troca de processos}

A rotina de troca de processos tem como entrada duas variáveis: o fundo do PCB do processo atual e o fundo do PCB do próximo processo. Para obtermos tais dados, inicialmente precisamos identificar o número do processo atual, armazenado na variável handler\_currenttaskid\_str. A partir disso, com o auxílio da tabela de processos, veririficamos um a um em round-robin qual o próximo processo ativo.

Tendo o número dos processos atual e próximo, podemos calcular o endereço do PCB de ambos. Para isso, realizamos a simples equação $PCB_{id} = (id - 1) * 68 + base$ para os dois processos e armazenamos os resultados nas variáveis handler\_currenttaskid\_str e handler\_nexttask\_str, que serão usadas na etapa da troca de processos.

Caso o próximo processo a ser executado venha a ser o mesmo que está atualmente sendo executado, a rotina de tratamento de interrupção ignora a etapa de troca de processos e retorna à execução da rotina que estava sendo executada anteriormente sem qualquer alteração, já que o valor dos registradores antes da interrupção estavam sendo armazenados na pilha.

\subsection{A troca de processos}

A troca de processos se dá em poucos passos usando-se instruções especiais que permmitem que haja um grande número de dados empilhados/desempilhados com apenas uma instrução. Inicialmente zera-se a pilha do modo IRQ e restabelece-se os registradores como estavam antes di início da troca de processos. Depois disso, muda-se o endereço do ponteiro de pilha para o PCB do processo atual. O grande truque vem no próximo passo: empilha-se todos os registradores. Como a estrutura do PCB foi feito tendo este processo em mente, a posição dos dados dos registradores cai exatamente como foi descrito na figura \ref{pcb}. Após o armazenamento do estado atual, muda-se novamente o endereço do ponteiro de pilha para o PCB da próxima instrução. Do mesmo modo que o armazenamento, desempilha-se os o valor dos registradores, que são exatamente como estava empilhado este processo quando foi armazenado. Com isso, falta apenas restaurar o process counter para o ponto que o processo estava executando, o que vai ser descrito em seguida.

\subsection{Um caso especial}

Como descrito acima, caso se confirme que há apenas uma instrução ativa na tabela de processos, não é feita a troca de processos. Porém, antes de se retornar ao processo anterior, não podemos nos esquecer que devemos zerar a pilha do modo IRQ já não há mais dados relevantes nela e assim prevenimos que ela estoure seu tamanho. Outra ação importante é a restauração dos registradores que foram utilizados durante a rotina de tratamento.

\subsection{Retorno à execução da nova rotina}

Como os registradores, o ponteiro de pilha, o endereço de retorno e o registrador de estados já estão com os dados do próximo processo, devemos agora apenas fazer com que o a instrução imediatamente posterior à aquela executada antes da interrupção seja executada. Porém, não podemos nos esquecer que o pipeline do processador fez com que o endereço da instrução duas vezes à frente tivesse sido armazenada. Para compensar isso, devemos subtrair o tamanho de uma instrução (quatro bytes) do endereço que vai ser colocado no process counter.

\section{System calls}

Uma system call nada mais é do que uma interrupção de software causada pelo kernel. Como uma interrupção de hardware, uma vez que é causada, ela executa a instrução apontada no vetor de interrupções, que foi instalada anteriormente na inicialização do sistema. A rotina de tratamento também está localizada no arquivo handler.s e é executada em modo SVC, que é privilegiado. As únicas instruções que chamam tais system calls são as rotinas fork, exec e exit.

\subsection{Propriedades gerais das system calls}

Escrever quando terminar de juntar as system calls\ldots

\subsection{fork}

Em um sistema operacional, a system call fork é responsável pela criação de novos processos. Para tal, ela duplica o processo que a criou, onde o único meio de se identificar qual o processo pai é pelo número de retorno. Caso o número de retorno seja 0, significa que este é o processo filho, e caso seja qualquer outro número, é o processo pai que retornou o identificador do processo filho. 

Nosso fork teve de ser ligeiramente alterado por causa de uma simplificação que fizemos em nosso kernel. Como dito anteriormente, temos uma área de dados única para todos os processos. Com isso, fica impossível de se duplicar a área de dados de um processo, o que não fazemos.

O processo de duplicação de um processo se inicia com o empilhamento dos registradores de dados (r0 a r12) e do endereço de retorno (link register) por duas vezes. O motivo é que o primeiro empilhamento serve para a restauração do estado ao fim do processo de duplicação e a segunda para o processo que vai a ser duplicado. Então, tentamos encontrar qual o primeiro espaço disponível dentro da tabela de processos. Uma vez encontrado o espaço, temos de encontrar o espaço do PCB reservado para este processo, onde iremos popular com os dados do estado em execução. Porém, além disso, temos também de duplicar a pilha, que é um processo um pouco mais complexo. Para tal, primeiro temos de descobrir o tamanho da pilha atual. Então, começamos a copiar os dados de uma pilha para a outra. Finalmente, colocamos no ponteiro de pilha do PCB do novo processo o topo da pilha recém copiada. Uma vez resolvido o problema da cópia de pilha, apenas duplicamos os dados do registrador de estados, do link register, do process counter e de todos os registradores de dados. Finalmente, quando o processo está totalmente copiado, devemos habilitar o processo na tabela de processos e restaurar todos os registradores empilhados de volta ao seus lugares, onde o link register entrará no lugar do process counter.

\subsection{exec}

\subsection{exit}

\section{Shell}
