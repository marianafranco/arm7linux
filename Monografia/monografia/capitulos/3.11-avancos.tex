\section{Avanços Finais} \label{sec:avancos}
\index{sistema!avancos} 

Após a primeira revisão da monografia, algumas modificações foram realizadas para o término do sistema.

%-------------------------------------------
% Shell
%-------------------------------------------
\subsection{Shell} \label{sub:shell}
\index{sistema!avancos!shell}

Novos comandos foram adicionados:

\begin{itemize}

\item start <name> [<arg>] : inicializa a \emph{thread} com o parâmetro passado em <arg>. O parâmetro deve ser um número em hexadecimal de 0 à F.
\item end pid <num> : finaliza a \emph{thread} pelo número de seu pid (de 2 à 9). Não é possível finalizar o \emph{shell}.
\item end all : finaliza todas as \emph{threads} ativas, menos o \emph{shell}.

\end{itemize}

Além disso, uma estrutura, \textbf{pid\_name}, foi criada no arquivo \textbf{terminal.c} para que fosse possível relacionar o nome de uma \emph{thread} com o seu pid.

E no arquivo \textbf{tasks.c}, criou-se a estrutura \textbf{name\_address} para relacionar o nome de todas as \emph{threads} disponíveis do sistema e seus respectivos ponteiros de função. Assim, para adicionar uma nova \emph{thread} é necessário criar uma nova entrada nessa estrutura para que o nome da \emph{thread} passe à figurar na lista apresentada pelo comando \emph{listtasks}, podendo-se então inicializá-la normalmente pelo comando \emph{start}.


%-------------------------------------------
% Threads
%-------------------------------------------
\subsection{Threads} \label{sub:threads}
\index{sistema!avancos!threads}

Para guardar o ponteiro de função de uma \emph{thread} na estrutura \textbf{name\_address}, citada do item anterior, esta deve possuir a seguinte assinatura:

\begin{lstlisting}
void <nome_da_thread>(int <value>);
\end{lstlisting}

Ou seja, toda \emph{thread} do sistema consiste de uma função do tipo \emph{void} que tem como argumento um valor do tipo inteiro.

Deste modo, foram criadas 8 \emph{threads} para exemplificar o funcionamento do \emph{microkernel}:

\begin{itemize}
\item \textbf{display\_pid}: Apresenta no display de 7 segmentos o pid da \emph{thread}.
\item \textbf{set\_led}: Acende os leds conforme o valor em hexadecimal passado em argumento.
\item \textbf{set\_segment}: Coloca o valor passado em argumento no display.
\item \textbf{mutex\_test}: Exemplo de mutex. Acende o led passado em argumento (1 à 4) e coloca no display o pid da \emph{thread}.
\item \textbf{fork\_test}: Imprime na tela o valor do pid da \emph{thread} filha retornado pelo \emph{fork} para a \emph{thread} mãe. 
\item \textbf{dips\_to\_leds}: Acende os leds conforme o valor apresentados nos \emph{switches} da placa.
\item \textbf{dips\_to\_segments}: Coloca no display o valor apresentados nos \emph{switches} da placa.
\item \textbf{malicious\_handler}: Altera o vetor de interrupção para apontar para um rotina maliciosa. Ao executar essa \emph{thread} o sistema é bloqueado, devendo-se então reinicializar o mesmo.
\item \textbf{tictactoe}: Jogo da velha que utiliza o terminal para a entrada dos comandos.
\end{itemize}



%-------------------------------------------
% Mutex
%-------------------------------------------
\subsection{Mutex} \label{sub:mutex}
\index{sistema!avancos!mutex}

A rotina descrita no item \ref{cap:mutex} foi utilizada em duas rotinas. A primeira, chamada de mutex\_test, acende e apaga um led. Caso o led esteja aceso, o mutex está habilitado. Ao se iniciar uma outra thread com o mesmo código, percebe-se que os dois leds não acendem ao mesmo tempo.

Outro uso do mutex é no programa tictactoe, que concorre com o shell no uso da porta serial e da tela. Para tal, força-se uma troca de threads com a chamada de sistema switch\_thread (descrita abaixo) e habilita-se a exclusão mútua de código entre o shell e o tictactoe.

%-------------------------------------------
% System Calls
%-------------------------------------------
\subsection{Chamadas de sistema} \label{sub:syscalls}
\index{sistema!avancos!syscalls}

Para o melhor funcionamento do terminal, duas novas chamadas de sistema foram criadas.

\subsubsection{print}

Chamada quando se deseja imprimir uma seqüência de caracteres completa (linha) no terminal. Como as chamadas de sistema são executadas em modo privilegiado, outras interrupções são desabilitadas, permitindo com que nada interrompa a rotina até sua finalização.

\subsubsection{switch\_thread}

Chamada de sistema criada para forçar o chaveamento de threads. Ao ser chamada, simula uma interrupção de timer, fazendo com que se chaveie para a próxima thread e com que o timer seja reinicializado. É um artifício utilizado para que se force que o mutex da próxima thread seja inicializado antes do mutex da thread atual.