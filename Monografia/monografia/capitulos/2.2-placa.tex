 % A Placa Experimental Evaluator-7T
\section{A Placa Experimental Evaluator-7T} \label{sec:conceitos_placa}
\index{conceitos!placa}

O principal elemento de hardware deste projeto é a placa experimental ARM Evaluator-7T, baseada no processador ARM7TDMI, um processador RISC de 32 bits capaz de executar o conjunto de instruções denominado Thumb.

Os principais elementos presentes na arquitetura da placa Evaluator-7T são os seguintes:

\begin{itemize}

\item Microcontrolador Samsung KS32C50100

\item 512kB EPROM flash

\item 512kB RAM estática (SRAM)

\item Dois conectores RS232 de 9 pinos tipo D

\item Botões de reset e de interrupção

\item Quatro LEDs programáveis pelo usuário e um display de 7 segmentos

\item Entrada de usuário por um interruptor DIP com 4 elementos

\item Conector Multi-ICE

\item Clock de 10MHz (o processador usa-o para gerar um clock de 50MHz)

\item Regulador de tensão de 3.3V

\end{itemize}

A figura \ref{arch_e7t} mostra a organização desses elementos na placa experimental.

\begin{figure}[!ht]
\centering 
\includegraphics[height=12cm]{figuras/board_arch.png}
\caption{Arquitetura da placa Evaluator-7T. \cite{E7TUserGuide} \label{arch_e7t}}
\end{figure}


Com relação à memória flash da placa, ela vem de fábrica com o bootstrap loader da placa e programa monitor de debug. O restante dela pode ser usado para os programas de usuário. A tabela \ref{table:mapamemflash}  mostra a faixa de endereços de cada região da memória.

% a tabela nao esta aparecendo no lugar certo (logo após o parágrafo acima)
\begin{table}[!ht]
\caption{Mapa da memória flash \cite{E7TUserGuide}}
\centering
\begin{tabular}{| c | c |}
\hline  \textbf{Faixa de endereço} & \textbf{Descrição}  \\ 
\hline  0x01800000 a 0x01806FFF & Bootstrap loader  \\ 
\hline  0x01807000 a 0x01807FFF & Teste de produção  \\ 
\hline  0x01808000 a 0x0180FFFF & Reservado  \\ 
\hline  0x01810000 a 0x0181FFFF & Angel  \\ 
\hline  0x01820000 a 0x0187FFFF & Disponível para outros programas e dados  \\ 
\hline 
\end{tabular}
\label{table:mapamemflash}
\end{table}

Já em relação às duas portas seriais presentes na placa, cada uma tem usos específicos. A primeira, chamada DEBUG, é usada pelo monitor de debug ou pelo programa bootstrap presente na placa. Ela está conectada ao UART1 do microcontrolador. A segunda, chamada USER, é de uso genérico e está disponível para uso em programas. Ela está conectada ao UART0 do microcontrolador.

%BSL
\subsection{Bootstrap Loader}

Como mencionado anteriormente, a memória flash da placa contém uma região reservada para os programas Bootstrap Loader (BSL) e o programa monitor de debug chamado Angel.

O BSL é o primeiro programa a ser executado pelo microcontrolador quando esta é ligada ou reiniciada. Suas principais funções são:

\begin{itemize}

\item Fazer a conexão com o computador através da porta serial e uma aplicação de terminal, como o HyperTerminal do Windows

\item Prover a infraestrutura necessária à configuração da placa

\item Prover ajuda ao usuário

\item Gerenciar imagens de memória como um conjunto de módulos executáveis

\item Carregar aplicações na SRAM e executá-las

\end{itemize}

\subsubsection{Comunicação com o PC}

Neste projeto, foi usado um PC com o sistema operacional Windows XP para fazer a comunicação com o BSL da placa Evaluator-7T. Essa comunicação é feita através de um cabo serial conectado à porta COM1 (Debug) da placa. Estando a placa conectada à porta serial e energizada com uma fonte de alimentação própria, pode-se estabelecer a comunicação com o BSL por meio do programa HyperTerminal. As configurações de comunicação utilizadas foram:

\begin{itemize}

\item Velocidade de transferência de 9600 bauds

\item 8 bits de dados

\item Sem paridade

\item 1 bit de parada

\item Sem controle de fluxo

\end{itemize}

Após a configuração adequada da placa, é preciso reiniciá-la, pressionando o botão SW1 (SYS RESET). Então, a placa envia a seguinte mensagem ao terminal:

\begin{lstlisting}
ARM Evaluator7T Boot Strap Loader Release 1.01
Press ENTER within 2 seconds to stop autoboot
\end{lstlisting}

Pressionando a tecla \emph{Enter} em até dois segundos da exibição da mensagem acima, nenhum outro módulo da memória é executado, além do BSL. Desse momento em diante, o BSL exibe seu editor de linha de comando, a partir do qual é possível gerenciar, embarcar e executar programas na placa. A figura \ref{bsl_ht} mostra o HyperTerminal com o BSL carregado e aguardando um comando.

\begin{figure}[!ht]
\centering 
\includegraphics[height=8cm]{figuras/bsl_ht.png}
\caption{Editor de linha de comando do BSL via HyperTerminal \label{bsl_ht}}
\end{figure}

\subsubsection{Carregando e executando programas via BSL}

Após a compilação de um projeto, o ambiente de desenvolvimento cria uma imagem de memória em formato binário (extensão \emph{.bin}). Essa imagem, no entanto, não pode ser carregada diretamente na placa através do BSL. Ela deve ser convertida para o formato UUE (Unix-to-Unix Encoding), o qual é uma representação em arquivo texto do arquivo binário original. Neste projeto, foi utilizado para essa conversão o programa \emph{uuencode} fornecido no CD-ROM que acompanha a placa Evaluator-7T.

Uma vez convertido o arquivo para o formato adequado, ele está pronto para ser enviado à Evaluator-7T. Para isso, pode-se usar dois diferentes comandos do BSL: \emph{Download} ou \emph{FlashLoad}.

O comando \emph{Download} carrega uma imagem na memória RAM da placa. A sintaxe desse comando é:

\begin{lstlisting}
download [<endereço>]
\end{lstlisting}

O parâmetro \emph{<endereço>}, que é um número em base hexadecimal, indica em qual endereço da RAM a imagem será carregada. Se esse endereço não for especificado, a imagem é carregada na posição 0x8000.

Assim que o comando é executado, o BSL espera a transferência de um arquivo texto com a imagem de memória desejada. No HyperTerminal, isso é feito pelo comando ``Enviar arquivo texto'' e apontando para o arquivo desejado, no formato UUE. Terminada a transferência, o BSL informa quantos bytes foram recebidos e a posição de memória a partir da qual eles foram gravados.

Já o comando \emph{FlashLoad} carrega uma imagem na placa e a salva diretamente na memória flash da mesma. Sua sintaxe é a seguinte:

\begin{lstlisting}
flashload <endereço>
\end{lstlisting}

Neste comando, o parâmetro \emph{<endereço>} é obrigatório, também é um número em base hexadecimal e especifica o endereço da memória flash no qual a imagem será gravada. O envio do arquivo é feito da mesma maneira que o comando \emph{Download}. Como não há restrições quanto ao valor que o usuário pode inserir nesse comando, cabe a ele mesmo tomar cuidado para não escrever dentro da faixa de endereços de 0x01800000 a 0x0180FFFF, uma vez que é nessa área da flash que estão os módulos BSL e de teste de produção.

O comando \emph{FlashLoad} não é o único que manipula a memória flash da placa no BSL. Existem também os comandos \emph{FlashWrite} e \emph{FlashErase}. O primeiro escreve na memória flash uma determinada área da RAM, enquanto que o segundo sobrescreve uma uma faixa de endereços da flash com 0xFF. As sintaxes desses comandos são:

\begin{lstlisting}
flashwrite <endereço> <fonte> <comprimento>

flasherase <endereço> <comprimento>
\end{lstlisting}

Mais uma vez, é preciso exercer cautela durante a utilização desses comandos para não comprometer a área de memória onde se encontram os módulos BSL e de teste de produção.

Carregada a imagem na memória RAM ou na memória flash, ela está pronta para execução. Para executá-la, deve-se, primeiramente, verificar se o Program Counter (PC) do BSL está apontando para a posição de memória onde foi gravada a imagem. Isso é feito através do comando \emph{PC}, cuja sintaxe está abaixo.

\begin{lstlisting}
pc [<endereço>]
\end{lstlisting}

Esse comando permite verificar a posição a partir da qual o BSL iniciará a execução, se o parâmetro \emph{<endereço>} não for especificado. Quando esse comando é feito com um argumento, o valor do PC é alterado para o valor do argumento inserido. Por exemplo, \emph{pc 10000} coloca o PC na posição de memória 0x10000. Quando os comandos \emph{Download} e \emph{FlashLoad} são executados, o PC é atualizado automaticamente para o valor inserido no parâmetro \emph{<endereço>} desses comandos.

O próximo passo para a execução da imagem pode ser feito com dois comandos diferentes: \emph{Go} ou \emph{GoS}. Ambos iniciam a execução de um programa a partir da posição de memória definida no PC. Enquanto o primeiro executa o programa em Modo Usuário, o segundo o faz em Modo Supervisor (SVC). Opcionalmente, pode-se inserir argumentos de entrada do programa quando esses comandos são chamados. A sintaxe deles é:

\begin{lstlisting}
go [<argumentos do programa>]

gos [<argumentos do programa>] 
\end{lstlisting}

Assim, o programa começa a executar na placa. Caso seja necessário retornar ao BSL, deve-se reiniciar a placa, pressionando-se o botão SYS RESET. Qualquer imagem que tenha sido carregada apenas na RAM será perdida.

%Angel
\subsection{Angel Debug Monitor}

O monitor de debug Angel é fornecido conjuntamente com diversas placas da ARM e suas parceiras. Suas principais funcionalidades são:

\begin{itemize}

\item Função de depuração de código, incluindo inspeção de memória, download e execução de imagens de memória, uso de breakpoints e execução passo-a-passo

\item Inicialização da CPU e da placa e tratamento básico de exceções

\item Uma biblioteca ANSI C completa, com uso de semihosting para prover serviços do computador host que não estão disponíveis na placa

\end{itemize}

Há duas maneiras pelas quais o Angel se comunica com o ambiente de desenvolvimento de software.

A primeira é através da biblioteca de interfaces chamada "Remote\_A". Por ela, os depuradores se comunicam com um alvo do Angel quando fazem depuração ou execução de código.

A segunda é por meio de interrupções de software (SWI). O código do programa faz uma SWI para solicitar serviços dos Angel diretamente ou através da biblioteca C do toolkit.
