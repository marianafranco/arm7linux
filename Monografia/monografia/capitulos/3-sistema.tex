%
%~~
%~~  O Sistema Operacional KinOS
%~~
%

\chapter{O Sistema Operacional KinOS} \label{chap:sistema}
\index{sistema}

O principal objetivo do projeto é auxiliar o ensino de sistemas operacionais e da arquitetura ARM nas disciplinas de Sistemas Operacionais e Laboratório de Microprocessadores. Para tal, foi desenvolvido um microkernel, apelidado de KinOS, cujas funções básicas são o chaveamento de threads através de interrupção de timer, as chamadas de sistema, as rotinas de manipulação de hardware, funções de semáforo e um shell.

%Lembretes:
% se todos os slots estiverem ocupados, ao se iniciar o 10o processo, o programa trava
%-timer, microkernel, KinOK, hardware, shell, ARM, coderwarrior, assembly, nome dos arquivos, threads, fork, exec, exit, user, thread_array, offset, link register, process counter
%escrever sobre os processos-exemplo
% escrever sobre o software utilizado
% perspectivas
%\item{Colocar como o programa foi desenvolvido}
%\item{Colocar Mutex}
%\item{Colocar a referencia das seções}
%\item{Variáveis em assembly}
%\item{Explicar que o código foi baseado na experiencia do mutex}
%\item{Na descricao do fork poderia dizer que ao duplicar a pilha estah copiando as variaveis locais; isto eh, embora as variaveis globais sejam comuns a todos os processos (e por isso eles talvez devessem ser chamados de threads), as variaveis locais sao copiadas.}
%\item{Daria para fazer uns testes com variaveis locais, mostrando que depois de se criar dois processos; os dois estao com variaveis locais diferentes?}
%\item{Colocar pesquisa inicial (ver tambem as referencias e documentos de acompanhamento iniciais)}
%\item [MARI] Dar uma olhado no artigo sobre interrupções: Exception and Interrupt Handling in ARM. Tem figurinhas legais lá :)
%revisar portugues e fazer leitura cruzada
%Colocar mais bibliografias

\section{Organização do código}

A estrutura de arquivos do projeto pode ser vista na figura \ref{arquivos}. Pode-se dividi-lo em cinco partes: 

\begin{figure}[!ht]
\centering 
\includegraphics[width=4cm]{figuras/arquivos.pdf}
\caption{Estrutura de arquivos. \label{arquivos}}
\end{figure}

\begin{itemize}
\item{\textbf{Raiz} Contém os arquivos de inicialização da placa}
\item{\textbf{Pasta ``apps''} Contém os programas que serão executados pelo microkernel}
\item{\textbf{Pasta ``interrupt''} Contém as rotinas de tratamento de interrupção}
\item{\textbf{Pasta ``peripherals''} Contém rotinas de manipulação de hardware}
\item{\textbf{Pasta ``syscalls''} Contém as chamadadas de sistema}
\item{\textbf{Pasta ``mutex''} Contém rotinas de semáforo}
\end{itemize}

A pasta \emph{KinOS\_Data} não é considerada parte do projeto pois é utilizada pelo CodeWarrior para o armazenamento do código compilado.

\subsection{Raiz}

Os arquivos encontrados na raiz do projeto são responsáveis pela inicialização da placa e pela declaração de constantes globais.  O arquivo startup.s contém a chamada inicial do microkernel, onde toda parte de inicialização em assembly é feita. Já o arquivo cinit.c também contém a parte de inicialização, porém, a parte que deve ser executada em C. Finalmente, o arquivo constants.h é responsável por armazenar as constantes que são utilizadas em todo o projeto.

\subsection{Pasta ``apps''}

Há apenas um arquivo e seu cabeçalho nesta pasta. Nele, várias funções são declaradas, onde cada declaração é considerada uma thread pelo microkernel. 

\subsection{Pasta ``interrupt''}

Todas as rotinas que tratam e instalam interrupções -- tanto de hardware quanto de software -- estão localizadas nesta pasta. O arquivo handler\_irq.s contém a rotina em assembly que trata das interrupções de hardware, as encaminha para a rotina específica de acordo com a sua fonte e faz o chaveamento de threads. O arquivo irq.c contém uma única rotina, que realiza a instalação da rotina de tratamento de interrupção tanto de hardware quanto de software. A rotina de tratamento de interrupção de software é feita no arquivo handler\_swi.s, que identifica o tipo de interrupção e encaminha para alguma das chamadas de sistema, encontradas em swi.c.

\subsection{Pasta ``peripherals''}

As rotinas de inicialização e controle dos periféricos se encontram todas nesta pasta. As do botão estão no arquivo button, da chave DIP no arquivo dips, do display de sete segmentos em segment, dos LEDs em led e do timer em timer.

\subsection{Pasta ``syscalls''}

As chamadas de sistema estão escritas em assembly e se encontram em três arquivos, uma para cada chamada. São elas as chamadas fork, exec e exit.

\subsection{Pasta ``mutex''}

No arquivo mutex há apenas as funções que permitem a exclusão mútua de código.

\section{Estruturas de dados}

A fim de se facilitar a programação e o entendimento do projeto, foram criadas duas estruturas de dados que são acessadas em assembly. A primeira, o Process Control Block é responsável pelo armazenamento do estado de um processo. Já a Lista de Threads realiza o controle de quais threads estão ativas.

\subsection{Process Control Block} \label{sub:PCB}

O Process Control Block (ou simplesmente PCB) é um estrutura de dados que guarda todas as informações de uma thread que aguarda para ser executada enquanto outras estão ativas. Há um PCB para cada uma das nove threads e cada uma ocupa 68 bytes. Ou seja, o espaço total ocupado pelos PCBs é de 9 $\cdot$ 68 = 612 bytes. Estes 68 bytes estão estruturados como explicitado na figura \ref{pcb}. Cada posição da tabela ocupa uma palavra (4 bytes). A primeira posição é em (base do PCB - 4), a segunda em (base do PCB - 8) e assim por diante. Como podemos observar pela figura, as posições 1 a 15 ((base do PCB - 4) a (base do PCB - 60)) armazenam o conteúdo dos registradores r0 a r14 do modo user em ordem inversa. A posição 16 (base do PCB - 64) armazena o link register do modo IRQ, ou seja, o endereço de retorno da interrupção. Finalmente, a posição 17 armazena o registrador de estado do modo user. Estes registradores armazenados permitem estabelecer um retrato preciso do estado do processo quando houve o chaveamento e permite também que este estado seja restabelecido quando for o turno deste processo voltar a ser executado. A estrutura tem seu espaço reservado no arquivo handler\_irq.s, e é nomeado com a variável process\_control\_block, que indica a base da estrutura. Cada um dos PCBs está logo a seguir do anterior. Por exemplo, a base do primeiro PCB está em (process\_control\_block - 68), do segundo em (process\_control\_block - 2 $\cdot$ 68) e assim por diante.

\begin{figure}[!ht]
\centering 
\includegraphics[height=10cm]{figuras/pcb.pdf}
\caption{Estrutura de dados do PCB. Fonte: \cite{Sloss2001} \label{pcb}}
\end{figure}

\subsection{Vetor de threads}

O vetor de threads é uma lista que armazena quais das threads estão ativas e quais não estão, a fim de se identificar quais devem ser colocadas em execução. Cada identificador ocupa 4 bytes, e pode ter os valores 0 (inativo) ou 1 (ativo). Como há 9 processos, o tamanho deste vetor é de 4 $\cdot$ 9 = 36 bytes. Seu espaço é reservado no arquivo handler\_irq.s, com o nome de thread\_array. No exemplo na figura \ref{vetor} podemos ver que as threads 1, 2 e 4 estão ativas, enquanto que as outras não estão.\\

\begin{figure}[!ht]
\centering 
\includegraphics[width=7.5cm]{figuras/vetorThreads.pdf}
\caption{Vetor de threads. \label{vetor}}
\end{figure}

\section{Configuração de hardware e software}

Nesta seção são apresentados os modos como o hardware e o software descritos anteriormente são utilizados. Será indicado como foi feito o particionamento da memória, a utilização dos modos do processador e os modos de teste do código. 

\subsection{Memória}

A memória volátil da placa foi estruturada como indicado na figura \ref{memoria}. Para todo espaço das pilhas, programas, código, vetor de interrupções e área de dados, o espaço disponível é de 128KB (de 0x0 a 0x20000). Como pôde ser visto anteriormente, a memória entre 0x0 e 0x20 contém o vetor de interrupções e deve ser reservado. A pilha do modo SVC começa no endereço 0x7F80, cresce para baixo e não deve invadir a área reservada para o vetor de interrupção. Já a pilha do modo IRQ, começa no endereço 0x8000, também cresce para baixo e não deve invadir o espaço reservado para a pilha do modo SVC. O código do kernel e dos programas começa no endereço 0x8000, mas ao contrário da pilha do modo SVC, cresce para cima. Logo após o código, temos uma área reservada para os dados globais. Finalmente, as pilhas de usuário começam no endereço 0x20000 e crescem para baixo. Cada uma tem um offset relativo à anterior de 4048 bytes.

\begin{figure}[!ht]
\centering 
\includegraphics[height=13cm]{figuras/memoria.pdf}
\caption{Estrutura da memória. Fonte: \cite{Sloss2001} \label{memoria}}
\end{figure}

\subsection{Modos do processador}

Dentre os sete modos disponíveis na placa, apenas quatro deles são utilizados: o modo d usuário (user), o modo de serviço (SVC), o modo de sistema (SYS) e o modo de interrupção (IRQ). O primeiro é o modo não privilegiado no qual os processos são executados. O segundo, é o modo de inicialização do kernel e de execução das system calls, que é privilegiado. Já o terceiro, é idêntico ao modo de usuário, mas com privilégios. Ele é utilizado na inicialização do sistema para definir a pilha do modo de usuário. Finalmente, o quarto é um modo que também é privilegiado, mas que é usado quando há interrupções de hardware e portanto, é usado quando há o chaveamento de processos (interrupção de timer) ou qualquer outra interrupção que não a de software. É importante ressaltar que os modos privilegiados quando chamados por interrupção desabilitam outras interrupções. Isso não permite que ocorra interrupções aninhadas, essencial para o funcionamento do código.

\subsection{Modos de teste}

Depurar o código com a placa não é possível em todas as situações. Quando o código que está sendo executado está dentro de uma região onde as interrupções estão desabilitadas, como no código de tratamento de interrupção, não se pode fazê-lo. Para contornar tal problema, foi utilizado o emulador disponível na IDE CodeWarrior, o ARMulator. Como ele foi desenvolvido para vários modelos de placa, utiliza endereços de periféricos diferentes da placa Evaluator 7-T, e além disso, não têm o módulo Angel de debug. Para manter a compatibilidade entre o emulador e a placa, nas partes onde o código se diferencia, como na inicialização do timer, foram colocados ambos códigos. A seleção de qual dos dois será executado depende de uma variável global emulator, que é declarada no arquivo constants.h. Caso seja 1, o código executado é o do emulador, caso seja 0, é o código da placa com Angel e caso seja 2 é o código para a placa com o Angel desabilitado. Uma outra vantagem do código no emulador é que ele permite com que ele possa ser testado sem a presença da placa.

\subsection{Angel}

O Angel é um programa contido na ROM da placa que realiza a comunicação entre a mesma e o computador que efetuou o upload do código. Além de permitir com que o código seja carregado na placa, o Angel realiza o processo de debug do código durante a execução. Para isso, deve haver uma comunicação constante entre a placa e o computador, que é feita através de interrupções. Uma vez que a placa é iniciada, o endereço do vetor de interrupções responsável pelas interrupções de hardware e se software apontam para um endereço pré-estabelecido do Angel. Caso se queira adicionar alguma outra rotina de tratamento de interrupções, deve-se encadear a rotina do Angel para que a comunicação com a placa não seja perdida.

\section{Inicialização}

O início do programa se dá no arquivo assembly statup.s. Nele, são feitas todas as operações que não podem ser feitas no código em C, como a inicialização das pilhas ou a criação da tabela de threads. Após esta etapa, há a inicialização em C, feita no arquivo cinit.c, que inicializa periféricos, instala rotinas de tratamento e inicia a primeira thread em modo usuário. A rotina completa de inicialização pode ser vista no esquema da figura \ref{inicializacao}.

\begin{figure}[!ht]
\centering 
\includegraphics[height=10cm]{figuras/inicializacao.pdf}
\caption{Fluxograma de inicialização. \label{inicializacao}}
\end{figure}

\subsection{Ponto de entrada e tipo de código}

O ponto de entrada do código é indicado pela instrução \verb|ENTRY|. Por padrão, o compilador assume que o código de entrada é ARM. Como descrito anteriormente, há dois tipos de assembly, o ARM e o THUMB. No microkernel, é utilizado apenas código ARM, já que ele fornece mais instruções e favorece a legibilidade. Um ponto negativo deste tipo de código é seu maior espaço ocupado na memória, mas isso não vem a ser um grande problema, pois temos espaço suficiente.

\subsection{Pilhas}

Antes de poder utilizar as pilhas é preciso que elas sejam inicializadas em cada um dos modos que virão a ser utilizados. Neste microkernel, são utilizados os modos de serviço, usuário/sistema e de interrupção. O modo como isto é feito é descrito abaixo:

\begin{lstlisting}
	MOV		r0,	#0xC0|0x12		; r0 = 0xC0 or 0x12 (0xC0 = IRQ disabled, 0x12 = IRQ mode)
	MSR		CPSR_c, r0			; status_register = r0
	MOV		sp, #0x8000			; stack pointer = 0x8000
\end{lstlisting}

A primeira instrução copia para r0 o que será substituído no registrador de estado. Neste exemplo, está se desabilitando as interrupções e mudando o modo do processador para o modo de interrupção. Em seguida, os dados do registrador r0 são colocados no registrador de estado. Uma vez que o estado foi alterado, pode-se mudar o ponteiro de pilha, que neste caso aponta para o endereço 0x8000. Uma operação semelhante pode ser feita tanto no modo de serviço quanto no modo de usuário, usando os endereços de pilha indicados anteriormente. Porém, se o estado for alterado para o modo de usuário fica impossível de se alterar o estado novamente. Para se resolver este problema, ao invés de se mudar para o estado de usuário, muda-se para o estado de sistema. Este é o mesmo modo que o de usuário (usa a mesma pilha e registradores), mas permite que o modo seja alterado novamente.

\subsection{Vetor de threads e número da thread}

O outro ponto importante da inicialização do código em assembly é a criação do vetor de threads. Para tal, temos de definir que todos os processos exceto o primeiro são inicializados desabilitados. Isto é feito com o código apresentado a seguir:

\begin{lstlisting}
	; Initializes the thread array with zeros (0 = thread disabled,
	; 1 = thread enabled)
	LDR		r0, =thread_array		; r0 = thread_array start address
	MOV		r1, #1					; r1 = 1
	STR		r1, [r0]				; address(r0) = r1
	MOV		r1, #0					; r1 = 0 (disabled)
	MOV		r2, #0					; r2 = 0
init_thread_array_loop
	ADD		r2, r2, #4				; r2 = r2 + 4
	CMP		r2, #36					; r2 = 36?
	BEQ		set_active_thread		; if yes, go to set_active_thread
	ADD		r3, r0, r2				; r3 = r0 + r2
	STR		r1, [r3]				; address(r3) = r1
	B		init_thread_array_loop	; return to init_thread_array_2
\end{lstlisting}

Nele, r0 armazena a base do vetor, que coincide com o espaço relativo à primeira thread. r1 contém o dado que será colocado na posição de memória. Na posição este valor é 1, e nos demais 0. r2 contém o offset que será somado à base para o cálculo do endereço absoluto, armazenado em r3. O algoritmo funciona inicialmente colocando 1 na base. Após isso, entra em um loop que aumenta o offset de 4 em 4 e coloca 0 em todos os outros espaços.

Ainda na inicialização em assembly, deve-se definir o número da thread que está sendo executada. Este dado é armazenado na variável current\_thread\_id. Pode-se ver abaixo como é definido o id do primeiro processo para 1:

\begin{lstlisting}
LDR		r0, =current_thread_id	; r0 = current thread id address
MOV		r1, #1					; r1 = 1
STR		r1, [r0]				; current thread id = 1
\end{lstlisting}

Finalmente, a inicialização em C pode ser iniciada. A chamada é feita definindo como endereço de retorno a função C\_entry e colocando este mesmo endereço no process counter.

\begin{lstlisting}
LDR 	lr, =C_Entry			; link register = C entry
MOV 	pc, lr					; process counter = C entry
\end{lstlisting}

\subsection{Periféricos}

Para alguns periférico da placa, como o display de sete segmentos, o timer e os botões, há uma rotina de inicialização que os habilita e define suas configurações. Suas chamadas são \verb|segment_init()|, \verb|timer_init()| e \verb|button_init()| respectivamente. Estas funções se encontram nos arquivos de cada um dos periféricos e são executadas logo no início da etapa C do processo de inicialização da placa.

\subsection{Instalação do tratamento de interrupção}

Como descrito anteriormente, caso uma interrupção de hardware ocorra, a instrução no endereço 0x18 é executada e caso seja uma interrupção de software, a instrução no endereço 0x08. Toda vez que se reinicia a placa, são colocados nestes endereços uma instrução que realiza um desvio para a rotina Angel, descrita anteriormente. 

Porém, se algum dos periféricos vai ser utilizado, a interrupção gerada por esse periférico não deve desviada para o Angel, e sim para uma rotina adequada. Para poder identificar qual a origem da interrupção e desviar para a rotina correta, devemos instalar uma nova rotina no vetor de interrupções, substituindo o desvio para o Angel. A instalação da rotina se dá através do desvio para a tal rotina. Todavia, não se pode apenas descartar o endereço do Angel, já que caso não se identifique a origem da interrupção, ainda deve-se desviar para ele. Este processo pode ser observado na figura \ref{chain}. Nele, \emph{Handler2} é a rotina de tratamento de interrupções, e \emph{Handler1} é o Angel.

A instalação da rotina de tratamento de interrupção é a mesma para interrupções de hardware e de software se dá abaixo:

\begin{lstlisting}
/* Angel branch instruction */
unsigned Angel_branch_instruction;
/* Angel instruction */
unsigned *Angel_address;
/* Getting Angel branch instruction */		
Angel_branch_instruction  = *vector_address;
/* Separate the instruction from the address */
Angel_branch_instruction ^= 0xe59ff000;
/* Calculating absolute address */
Angel_address = (unsigned *) ((unsigned)vector_address + Angel_branch_instruction + 0x8);
/* Store address in the propoer position */
if ((unsigned)vector_address == 0x18) {
	Angel_IRQ_Address = *Angel_address;
}
else {
	Angel_SWI_Address = *Angel_address;
}
/* Inserting handler instruction in the vector table */
*Angel_address = handler_routine_address;
\end{lstlisting}

Os parâmetros de entrada desta função são \verb|handler_routine_address|, o endereço da rotina de tratamento de interrupção e \verb|vector_address|, um ponteiro para a posição no vetor de interrupções onde será instalada a rotina. Sucintamente, o que esta rotina realiza é obter a instrução que está em \verb|vector_address|, aplica uma máscara à rotina para obter apenas o endereço e o salva em uma das variáveis: \verb|Angel_IRQ_Address| caso se esteja instalando a rotina de interrupção de hardware ou \verb|Angel_SWI_Address| caso seja a de software, além de colocar a nova instrução no vetor de interrupções. 

Um fator importante que deve ser ressaltado a importância do Angel quando se está usando a placa. Como já descrito anteriormente, o Angel se utiliza das interrupções de hardware e software para se comunicar com a placa. Portanto, se apenas modificarmos o código e substituirmos a instrução que está contida no vetor de interrupção, essa comunicação não se realiza e tanto a placa quanto o programa de debugger travam. Para solucionarmos este problema, devemos passar para a rotina de tratamento de interrupção os endereços que estavam anteriormente no vetor de interrupção, para o caso da interrupção ser do Angel, a rotina correta ser executada. Já no caso em que o código é apenas simulado no emulador, não é preciso armazenar o endereço do Angel.

\begin{figure}[!ht]
\centering 
\includegraphics[width=13cm]{figuras/chain.pdf}
\caption{Encadeamento de interrupções. Fonte: \cite{Sloss2001} \label{chain}}
\end{figure}

\subsection{Interrupção de timer}

A interrupção de timer é utilizada neste projeto para realizar o chaveamento entre as threads. Uma vez que haja a interrupção, o estado da thread atual é salva e a próxima thread é colocada em processamento. Para utilizá-la, devemos tanto habilitar quanto iniciar o timer. Essas tarefas são executadas com duas rotinas, sendo que a primeira já foi descrita anteriormente. Já o início do timer é dado pela função \verb|timer_start()|.

\subsection{Habilitando interrupções}

O último passo antes de se começar a executar o código do primeiro programa é habilitar simultaneamente o modo de usuário e as interrupções. Como isso só pode ser feito por código assembly, temos de usar a instrução especial de C \_\_asm, conforme o exemplo abaixo

\begin{lstlisting}
__asm {
	MOV		r1,	#0x40|0x10
	MSR 	CPSR_c, r1
}
\end{lstlisting}

O registrador r1 recebe 0x40, que indica a habilitação das interrupções e 0x10 que altera para o modo de usuário. Logo em seguida, o conteúdo deste registrador é passado para o registrador de estado. Finalmente, o primeiro programa é chamado com a função \verb\shell()\.

\section{Processos}

O kernel pode lidar com no máximo nove processos, nomeados de task1 a task9 no arquivo tasks.c. Como eles não têm área de dados própria, não pode-se chamá-los de processos. A implicação de se ter uma área de dados em comum é que todos os processos que rodam um mesmo programa compartilham os valores das variáveis. O mais correto, portanto, seria o chamá-os de threads.

Criamos algums programas exemplo que se utilizam dos periféricos da placa. 

TODO\ldots (Fazer código antes)

\section{Chaveamento de processos}

O chaveamento de processos é realizado inteiramente com o assembly escrito no arquivo handler\_irq.s. Ele consiste em sete passos, indicados na figura \ref{chaveamento}.

\begin{figure}[!ht]
\centering 
\includegraphics[width=15.5cm]{figuras/chaveamento.pdf}
\caption{Chaveamento de processos. \label{chaveamento}}
\end{figure}

\subsection{Identificação da interrupção}

\begin{lstlisting}
STMFD	sp!, {r0 - r3, lr}		; Stacking r0 to r3 and the link register
LDR 	r0, IRQStatus	 		; r0 = irq type address
LDR 	r0, [r0]				; r0 = irq type
TST 	r0, #0x0400				; irq type == 0x0400?
BNE		handler_timer 			; If yes, go to handler_timer
TST		r0, #0x0001				; irq type = 0x0001?
BNE		handler_button			; If yes, go to handler_button
LDMFD	sp!, {r0 - r3, lr}		; If it is not any of them, restore r0-r3 and lr
LDR 	pc, Angel_IRQ_Address	; and branch to the Angel routine
\end{lstlisting}

Uma vez que há a interrupção de timer, a chamada de interrupção de hardware que se encontra no vetor de interrupção é executada. Durante a instalação da rotina de tratamento de interrupção de hardware, colocou-se nesta posição a rotina handler\_board\_angel caso se estivesse usando a placa com o Angel, a rotina handler\_board\_no\_angel caso se estivesse usando a placa sem o Angel ou a rotina handler\_emulator caso estivesse usando o emulador. A direrença é que enquanto a primeira e a segunda tentam identificar qual a fonte de interrupção, a terceira já assume que a fonte é o timer, já que não há outros periféricos no emulador. Deve-se armazenar toda informação contida nos registradores que sao alterados durante o processo de tratamento de interrupção. Para tal, empilhamos os valores dos registradores r0 a r3, usados durante a rotina de chaveamento, a fim de que nenhum dado se perca durante o processo.

No caso do uso da placa, a fonte da interrupção se encontra no endereço 0x03ff4004, identificado com a variável \verb|INTPND|. Se o valor contido neste endereço é 0x0400, a fonte foi uma interrupção de timer, caso seja 0x0001, a fonte foi o botão da placa e caso contrário, a fonte foi o Angel. No primeiro caso, há um desvio para a rotina \verb|handler_timer|, no segundo para a rotina \verb|handler_button| e na terceira, para o endereço salvo durante a instalação de rotina de tratamento.

\subsection{Limpeza da interrupção de timer}

Quando é identificada a interrupção de timer, deve-se limpar a interrupção de timer, a fim de que ele possa interromper novamente no futuro. Para tal, executa-se a rotina timer\_irq, encontrada no arquivo timer.c. Como não podemos garantir que a rotina em C manterá intactos os registradores, temos de salvar todos e recupera-los após a chamada. Abaixo podemos observar o código que realiza o salvamento e a recuperação destes registradores.

\begin{lstlisting}
STMFD	sp!, {r4 - r12}			; Stack the rest of the registers (r4-r12)
BL		timer_irq				; Clear timer interruption
LDMFD	sp!, {r4 - r12}			; Load r4-12 registers again
\end{lstlisting}

Os registradores r0 a r3 não precisam ser salvos ou recuperados, pois no início da rotina de tratamento eles já foram empilhados para recuperação futura.

\subsection{Identificação da próxima thread}

O método de escolha da próxima thread que será posta em execução é escolhida pelo método \emph{round-robin}, ou seja, a próxima thread é escolhida por ordem numérica. O código para tal tarefa é apresentado abaixo:

\begin{lstlisting}
	CMP 	r0, #9 					; r0 == 9? (it is the last thread?)
	BEQ		last_thread				; If yes, branch last_thread
	ADD		r1, r0, #1				; If not, r1 = r0 + 1
	B		next_thread				; and branch to next_thread
last_thread
	MOV		r1, #1					; r1 = 1
next_thread
	SUB		r2, r1, #1				; r2 = r1 - 1
	MOV		r3, #4					; r3 = 4
	MUL		r2, r3, r2				; r2 = r2 * r3
	LDR		r3, =thread_array		; r3 = thread_array bottom address
	ADD		r2, r2, r3				; r2 = r3 + r2
	LDR		r2, [r2]				; r2 = thread array content
	CMP		r2, #1					; thread array content = 1?
	BEQ		set_addresses			; If yes, branch to set_addresses
									; Send to the next step the next active
									; thread in r1
	MOV		r0, r1					; If not, r0 = r1
	B		get_next_taskid_loop	; and loop to get_next_taskid_loop
\end{lstlisting}

Nele, r0 inicia com o número da thread atual. Caso ele seja igual a 9, a última thread da lista, deve-se iniciar novamente a procura desde a thread 1. Caso contrário, inicia-se com o próximo número. O resultado é armazenado em r1, onde se encontra o número da próxima thread. O valor em r1 é incrementado sucessivamente até encontrar um ponto no vetor de threads que tenha o valor 0, indicando que a thread não está ativa. O cálculo da posição de memória é dado a partir da seguinte função: $(r1 - 1) * 4 + bottom$ = posição relativa à thread r1, onde bottom é o endereço do início do vetor e 4 é o tamanho de cada espaço dentro do vetor.

\subsection{Localização dos PCBs}

A rotina de troca de processos tem como entrada duas variáveis: o PCB da thread atual e o PCB do próxima thread. Para obter tais dados, é necessário o número da thread atual e da thread que será colocada em execução. Como visto nos itens anteriores, estes dados já foram obtidos. Pode-se então aplicar o seguinte algoritmo:

\begin{lstlisting}
	LDR		r2, =current_thread_id		; r2 = current thread id address
	LDR		r2, [r2]					; r2 = current thread id
	CMP		r2, r1						; Is r2 = current thread id ==
										; next thread id
	BEQ		no_thread_switch			; If yes, branch to no_thread_switch
; Setting current_task_addr
	MOV		r0, #68						; Else start thread switch. r0 = 68
	MUL		r0,	r2, r0					; r0 = current thread id * 68
	LDR		r2, =process_control_block	; r2 = PCB bottom
	ADD		r0, r0, r2					; r0 = PCB bottom + id * 68
	LDR		r2, =current_task_addr		; r2 = current task addr addr
	STR		r0, [r2]					; current_task_addr = r0
; Setting next_task_addr
	MOV		r0, #68						; r0 = 68
	MUL		r0,	r1, r0					; r0 = next thread id * 68
	LDR		r2, =process_control_block	; r2 = PCB_bottom
	ADD		r0, r2, r0					; r0 = PCB bottom + next id * 68
	LDR		r2, =next_task_addr			; r2 = next_task_addr addr
	STR		r0, [r2]					; next_task_addr = r0
\end{lstlisting}

O primeiro ponto checado é se a thread atual é igual à thread que vai ser substituída. Caso isso se confirme, o chaveamento se encerra e nada ocorre. Caso contrário, o cálculo dos endereços dos PCBs é iniciado. A fórmula utilizada é: $PCB_{id} = (id - 1) * 68 + base$, onde id é o número da thread e base é o endereço do início dos PCBs. Ao fim do cálculo, estes dados são armazenados nas variáveis \verb|current_task_addr| e \verb|next_task_addr|, que serão utilizadas na próxima etapa do processo.

\subsection{A troca de processos}

A troca de processos se dá em poucos passos usando-se instruções especiais que permitem que haja um grande número de dados empilhados/desempilhados com apenas uma instrução. Inicialmente zera-se a pilha do modo de interrupção e restabelece-se os registradores r0 a r3, que estavam empilhados desde o do início da rotina de tratamento. Nota-se que o ponteiro não é totalmente zerado, ele é colocado em uma posição 20 bytes acima do esperado. Isto se dá porque há empilhadas 5 palavras (r0 a r3 e o link register) que logo em seguida virão a ser desempilhadas.

Depois disso, muda-se o endereço do ponteiro de pilha para o PCB do processo atual. Um truque vem no próximo passo: empilha-se todos os registradores com o ponteiro de pilha apontando para a posição (base - 60) do PCB. Deste modo, em uma única instrução todos os registradores são colocados em suas respectivas posições. Como a estrutura do PCB foi feita tendo este processo em mente, a posição dos dados dos registradores cai exatamente como foi descrito na figura \ref{pcb}. Após o armazenamento do estado atual, muda-se novamente o endereço do ponteiro de pilha para o PCB da próxima instrução. Do mesmo modo que o armazenamento, desempilha-se os o valor dos registradores, que são exatamente como estava empilhado este processo quando foi armazenado. 

\begin{lstlisting}
; Reset and save IRQ stack
	LDR		r0, =irq_stack_pointer		; r0 = irq_stack_pointer addr
	MOV		r1, sp						; r1 = irq stack pointer
	ADD		r1, r1, #5*4				; r1 = irq stack pointer + 5 (# of data in
										; the stack, r0-r3, lr) * 4 (size of a word)
	STR		r1, [r0]					; irq_stack_pointer = irq stack pointer
										; without the data that will be removed next
	LDMFD		sp!,{r0-r3,lr}			; Restore the remaining registers
; Load and position r13 to point into current PCB
	LDR		r13, =current_task_addr		; r13 = current task PCB bottom address address 
	LDR		r13, [r13]					; r13 = current task PCB bottom address
	SUB		r13, r13,#60				; r13 = current task PCB bottom address - 60
										; to point to the right place for the stacking
										; (next step)
; Store the current user registers in current PCB
	STMIA 	r13, {r0-r14}^				; Stacks the r0-r14 registers in the PCB
	MRS		r0, SPSR					; r0 = status register
	STMDB	r13, {r0,r14}				; Stacks r0 and r14
;Load and position r13 to point into next PCB
	LDR 	r13, =next_task_addr		; r13 = next task PCB bottom address address 
	LDR		r13, [r13]					; r13 = next task PCB bottom address 
	SUB		r13, r13,#60				; r13 = next task PCB bottom address - 60
										; to point to the right place for the stacking
										; (next step)
; Load the next task and setup PSR
	LDMNEDB	r13, {r0,r14}				; Restore r0 and r14 (IRQ mode)
	MSRNE 	spsr_cxsf, r0				; Restore status register
	LDMNEIA	r13, {r0-r14}^				; Restore r0-r14 for the user mode
	NOP									; NOP! (required for the above instruction)
; Load the IRQ stack into r13_irq
	LDR		r13, =irq_stack_pointer		; r13 = stack pointer address address
	LDR		r13,[r13]					; Restore previous stack pointer
	B		return						; Go to the end
\end{lstlisting}

\subsection{Retorno à execução da nova rotina}

Como os registradores, o ponteiro de pilha, o endereço de retorno e o registrador de estados já estão com os dados do próximo processo, deve-se apenas fazer com que o a instrução imediatamente posterior à aquela executada antes da interrupção seja executada. Porém, o pipeline do processador fez com que o endereço da instrução duas vezes à frente tivesse sido armazenado. Para compensar isso, deve-se subtrair o tamanho de uma instrução (4 bytes) do endereço que vai ser colocado no process counter. Todo este processo é feito com apenas uma instrução: \verb|SUBS 		pc, r14, #4|, que simultaneamente decrementa do endereço de retorno 4 e coloca o resultado no process counter.

\section{System calls}

Uma system call é uma interrupção de software causada pelo kernel para a execução de código que necessita de privilégios para ser executado. Como uma interrupção de hardware, uma vez que é causada, ela executa a instrução apontada no vetor de interrupções, que foi instalada anteriormente na inicialização do sistema. A rotina de tratamento está localizada no arquivo handler\_swi.s e é executada em modo SVC. As únicas instruções que chamam tais system calls são as rotinas fork, exec e exit.

\subsection{Propriedades gerais}

Uma vez que uma system call é chamada, umas das funções encontradas em \verb|swi.c| é invocada. O motivo para este passo intermediário é que todas as chamadas de sistema do kernel devem ter a mesma identificação junto à rotina de tratamento. Neste caso, todas são passadas com o primeiro parâmetro como 0. Além disso, todas devem passar o mesmo número de parâmetros, pois todas estão invocando a mesma função, chamada de \verb|syscall| que também é realizado nesta etapa.

Uma vez que a chamada \verb|syscall| é feita, ocorre uma interrupção de software. O procedimento que se passa neste caso é muito parecido com o de uma interrupção de hardware.

\begin{lstlisting}
STMFD 	sp!,{r0-r12,lr}			; Stack registers r0-12 and link register
LDR		r0,[lr,#-4]				; Calculate address of SWI instruction (r0 = lr-4)
BIC		r0,r0,#0xff000000		; Mask off top 8 bits of instruction to give SWI 
								; number
LDR		r1, Angel_SWI_Number	; r1 = Angel SWI Number
CMP		r0, r1					; Compare SWI number to angel interrupt number 
BEQ		goto_angel				; If it is angel interrupt, branch to goto_angel
MOV		r1, #0					; r1 = 0
CMP		r0, r1					; Compare SWI number to r1
BEQ		os_swi					; If it is OS SWI, branch to os_swi
\end{lstlisting}

Novamente há uma rotina de identificação da fonte de interrupção, que pode vir a ser uma do sistema operacional, ou do Angel. O primeiro passo desta rotina é o empilhamento de todos os registradores, para poder futuramente restaurar o estado atual. Em seguida, ocorre a identificação em si, onde uma máscara de bits é aplicada para se obter o identificador da interrupção. Caso ela seja Angel\_SWI\_Number, o estado do processador é restaurado e há um desvio para a instrução previamente armazenada durante a instalação. Caso ela seja 0, o valor estabelecido para o sistema, há um desvio para outro código que identifica quais das chamadas de sistema foi ativada.

Esta nova identificação pode ser observada abaixo. O primeiro passo é restaurar e armazenar novamente os valores dos registradores, já que na arquitetura ARM os valores passados pelos parâmetros de uma função são passados pelos primeiros registradores. Neste caso, r1 contém o tipo da chamada. Dependendo de qual for o valor, há desvios para \verb\pre_routine_fork\, \verb\pre_routine_exec\ e \verb\pre_routine_exit\

\begin{lstlisting}
LDMFD	sp!,{r0-r12,lr}		; Restore r0-r12 registers and link registers
STMFD 	sp!,{r0-r12,lr}		; and stores them again (in order to clean the registers)
MOV		r1,	#0				; r1 = 0
CMP		r0, r1				; Compare the first parameter to 0
BEQ		pre_routine_fork	; If it is equal, branch to the fork
MOV		r1,	#1				; r1 = 1
CMP		r0, r1				; Compare the first parameter to 1
BEQ		pre_routine_exec	; If it is equal, branch to the exec
MOV		r1,	#2				; r1 = 2
CMP		r0, r1				; Compare the first parameter to 2
BEQ		pre_routine_exit	; If it is equal, branch to the exit
LDMFD	sp!,{r0-r12,pc}^	; If it is an unidentified syscall, go back to the program,
							; restoring the registers and putting the return address in
							; the process counter
\end{lstlisting}

\subsection{fork}

TODO \ldots

Em um sistema operacional, a system call fork é responsável pela criação de novos processos. Para tal, ela duplica o processo que a criou, onde o único meio de se identificar qual o processo pai é pelo número de retorno. Caso o número de retorno seja 0, significa que este é o processo filho, e caso seja qualquer outro número, é o processo pai que retornou o identificador do processo filho. 

Nosso fork teve de ser ligeiramente alterado por causa de uma simplificação que fizemos em nosso kernel. Como dito anteriormente, temos uma área de dados única para todos os processos. Com isso, fica impossível de se duplicar a área de dados de um processo, o que não fazemos.

O processo de duplicação de um processo se inicia com o empilhamento dos registradores de dados (r0 a r12) e do endereço de retorno (link register) por duas vezes. O motivo é que o primeiro empilhamento serve para a restauração do estado ao fim do processo de duplicação e a segunda para o processo que vai a ser duplicado. Então, tentamos encontrar qual o primeiro espaço disponível dentro da tabela de processos. Uma vez encontrado o espaço, temos de encontrar o espaço do PCB reservado para este processo, onde iremos popular com os dados do estado em execução. Porém, além disso, temos também de duplicar a pilha, que é um processo um pouco mais complexo. Para tal, primeiro temos de descobrir o tamanho da pilha atual. Então, começamos a copiar os dados de uma pilha para a outra. Finalmente, colocamos no ponteiro de pilha do PCB do novo processo o topo da pilha recém copiada. Uma vez resolvido o problema da cópia de pilha, apenas duplicamos os dados do registrador de estados, do link register, do process counter e de todos os registradores de dados. Finalmente, quando o processo está totalmente copiado, devemos habilitar o processo na tabela de processos e restaurar todos os registradores empilhados de volta ao seus lugares, onde o link register entrará no lugar do process counter.

%-------------------------------------------
% System call EXEC
%-------------------------------------------
\subsection{exec}

A chamada de sistema \emph{exec} é responsável por substituir a imagem núcleo de um processo pela imagem do programa passado como argumento \cite{Tanenbaum2000}.

Nos sistemas operacionais tradicionais, como o Linux ou o Minix, o \emph{exec} é utilizado para iniciar um novo programa no mesmo ambiente do programa que executa a chamada de sistema. Normalmente o \emph{exec} é utilizado na criação de um novo processo da seguinte maneira: um processo já existente se duplica através da chamada de sistema \emph{fork}. O processo filho tem, então, seu código substituído pelo código que deve ser executado através da chamada de sistema \emph{exec}, que permite ao processo filho assumir seu próprio conteúdo, apagando de si o conteúdo do processo pai.

No KinOS, para que um \emph{thread} passe a executar outro programa, é necessário reinicializar o seu PCB, isso é feito pela chamada de sistema \emph{exec}.

Existem 4 principais entradas do PCB que necessitam ser reinicializadas: 

\begin{itemize}
\item o \emph{program counter} (PC - R13);
\item o \emph{link register} (LR - R14);
\item o \emph{stack pointer} (SP - R15);
\item e o \emph{saved processor status register} (SPSR).
\end{itemize}

Para reinicializar essas entradas, de forma que a \emph{thread} passe à executar um novo programa, primeiro é necessário calcular o início do PCB da \emph{thread} correspondente.

A rotina \emph{exec}, recebe como parâmetros o id da \emph{thread} que será alterada e o ponteiro para a função/programa que pretende-se executar, como mostrado a seguir:


\begin{lstlisting}
	void exec(int process_id, pt2Task process_addr);
\end{lstlisting}

Assim para calcular o endereço inicial do PCB, obtêm-se o endereço inicial da área reservada para armazenar todos os PCBs, a \textbf{process\_control\_block}, e adiciona-se à esta o valor de 68 multiplicado por \textbf{process\_id}, visto que cada PCB ocupa um espaço de 68 endereços de memória como mencionado na sessão \ref{sub:PCB}. O código responsável por calcular o PCB é apresentado a baixo:

\begin{lstlisting}
  LDR r3, =process_control_block  ; r3 = the start address of the PCB area
  MOV r4,#68         ; r4 = 68 (space for each process in the PCB)
  MUL r5,r1,r4       ; r5 = (task id) * 68
  ADD r3,r3,r5       ; r3 = PCB start address + r5
\end{lstlisting}

Em seguida, calculado o endereço inicial do PCB, altera-se suas entradas da seguinte maneira:

\begin{itemize}
\item LR (PCB[-4]) e PC (PCB[-64]) recebem o endereço da primeira instrução do novo programa (\textbf{process\_addr}).

\begin{lstlisting}
PCB[-4] = process_addr;
PCB[-64] = process_addr;
\end{lstlisting}

\item SP (PCB[-8]) recebe o endereço de início da pilha da \emph{thread}, fazendo com que esta seja zerada. Para cada pilha de \emph{thread}, 4048 bytes são reservados. 

\begin{lstlisting}
PCB[-8] =  início da pilha do modo usuário - (4048 * thread id);
\end{lstlisting}

\item SPSR (PCB[-68]) recebe 0x10, pois os programas devem rodar no modo usuário.

\begin{lstlisting}
PCB[-68] = 0x10;
\end{lstlisting}

\end{itemize}

Finalmente, após alterar as entradas mostradas a cima, a \emph{thread} começa a executar o novo programa.



%-------------------------------------------
% System call EXIT
%-------------------------------------------
\subsection{exit}

A chamada de sistema \emph{exit} é responsável por finalizar um processo, liberando espaço de memória para a execução de um novo processo \cite{Tanenbaum2000}.

No KinOS isso é realizado apenas colocando como desativado (igual à 0) o byte na lista de processos que  corresponde a \emph{thread} que se deseja finalizar. 

Para isso a rotina \emph{exit} recebe como parâmetro o id da \emph{thread} a ser terminada.

\begin{lstlisting}
	void exit(int process_id);
\end{lstlisting}

  

%-------------------------------------------
% Shell
%-------------------------------------------
\section{Shell}

TODO\ldots

\section{Semáforos}

TODO\ldots

\section{Inspiração}

Grande parte do código foi retirada do código presente nos exemplos incluídos no CD de demonstração da placa. O principal deles, é o código \emph{mutex}, desenvolvido por Andrew N. Sloss, de onde foi baseado o chaveamento de processos, a função de semáforo e as rotinas de manipulação de hardware.

TODO \ldots
